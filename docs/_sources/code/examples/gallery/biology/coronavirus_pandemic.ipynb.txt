{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Coronavirus pandemic\n",
    "\n",
    "This Jupyter notebook is an example of plotting **vector data** and derived **graph data**. It shows the exponential growth of COVID-19 case numbers in countries around the globe during the 2019-2020 coronavirus pandemic. It is based on data provided by the Johns Hopkins University (JHU).\n",
    "\n",
    "Wikipedia:\n",
    "\n",
    "- Virus: [SARS-CoV-2](https://en.wikipedia.org/wiki/Severe_acute_respiratory_syndrome_coronavirus_2)\n",
    "- Disease: [Coronavirus disease 2019 (COVID-19)](https://en.wikipedia.org/wiki/Coronavirus_disease_2019)\n",
    "- Global outbreak: [Coronavirus pandemic](https://en.wikipedia.org/wiki/2019%E2%80%9320_coronavirus_pandemic)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "import math\n",
    "import os\n",
    "\n",
    "import pandas as pd\n",
    "import networkx as nx\n",
    "import unified_plotting as up"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data retrieval from Johns Hopkins University (JHU)\n",
    "\n",
    "- GitHub repository: [JHU CSSE: COVID-19](https://github.com/CSSEGISandData/COVID-19)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fetch_from_repository():\n",
    "    base_url = 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/'\n",
    "    df_confirmed = pd.read_csv(base_url + 'time_series_covid19_confirmed_global.csv')\n",
    "    df_deaths = pd.read_csv(base_url + 'time_series_covid19_deaths_global.csv')\n",
    "    df_recovered = pd.read_csv(base_url + 'time_series_covid19_recovered_global.csv')\n",
    "    return df_confirmed, df_deaths, df_recovered\n",
    "\n",
    "\n",
    "def load_from_files():\n",
    "    # Data from repository, accessed on 7.4.2020, covers 22.1.2020 to 6.4.2020\n",
    "    base_path = '../../data/tables/covid19/'\n",
    "    df_confirmed = pd.read_csv(base_path + 'time_series_covid19_confirmed_global.csv')\n",
    "    df_deaths = pd.read_csv(base_path + 'time_series_covid19_deaths_global.csv')\n",
    "    df_recovered = pd.read_csv(base_path + 'time_series_covid19_recovered_global.csv')\n",
    "    return df_confirmed, df_deaths, df_recovered\n",
    "\n",
    "\n",
    "df_confirmed, df_deaths, df_recovered = load_from_files()\n",
    "# df_confirmed, df_deaths, df_recovered = fetch_from_repository()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Caution: Recovered cases are not reported for all countries, hence shapes of dataframes differ\n",
    "assert df_confirmed.shape == df_deaths.shape # == df_recovered.shape\n",
    "\n",
    "# Caution: Number of deaths is not monotonically increasing for every country (e.g. India: 4, 5, 4, 7, 10)\n",
    "# print('India:', df_deaths.iloc[131][4:].tolist()[45:])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data preparation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "def prepare_data(df, verbose=False, get_location=False):\n",
    "    \"\"\"Aggregate states of a country to a single entry. Make provinces of a country independent.\"\"\"\n",
    "\n",
    "    def list_duplicates(df):\n",
    "        def get_duplicates(df, col):\n",
    "            i_dup = df[col].duplicated()\n",
    "            return sorted(df[i_dup]['Country/Region'].unique())\n",
    "\n",
    "        def print_rows(df, country):\n",
    "            mask = df['Country/Region'] == country\n",
    "            print(df[mask])\n",
    "\n",
    "        for country in get_duplicates(df, 'Country/Region'):\n",
    "            print(country)\n",
    "            print_rows(df[['Province/State', 'Country/Region']], country)\n",
    "            print()\n",
    "\n",
    "    def rename_provinces(df, country):\n",
    "        m1 = df['Country/Region'] == country\n",
    "        m2 = df['Province/State'].notnull()  # mainland has NaN entry, provinces have name (non-null)\n",
    "        mask = m1 & m2\n",
    "        df.loc[mask, 'Country/Region'] = df.loc[mask, 'Province/State']\n",
    "        df.loc[mask, 'Province/State'] = float('nan')\n",
    "        return df\n",
    "\n",
    "    def cumulate_states(df, country):\n",
    "        c_mask = df['Country/Region'] == country\n",
    "        c_rows = df[c_mask].index\n",
    "        c_summed = df[c_mask].sum()\n",
    "        c_summed['Country/Region'] = country\n",
    "        c_summed['Province/State'] = float('nan')\n",
    "        c_summed['Lat'] = df[c_mask].iloc[0]['Lat']\n",
    "        c_summed['Long'] = df[c_mask].iloc[0]['Long']\n",
    "        df = df.drop(c_rows)\n",
    "        df = df.append(c_summed, ignore_index=True)\n",
    "        df = df.sort_values(by='Country/Region')\n",
    "        return df\n",
    "    \n",
    "    def transpose_and_remove_location(df):\n",
    "        df_t = df.transpose()\n",
    "        df_t = df_t.rename(columns=df['Country/Region'])\n",
    "        df_t = df_t.drop(['Country/Region', 'Province/State', 'Lat', 'Long'])\n",
    "        return df_t\n",
    "\n",
    "    if verbose:\n",
    "        print('Duplicate entries in \"Country/Region\" column BEFORE data preparation')\n",
    "        list_duplicates(df)\n",
    "    df = cumulate_states(df, 'Australia')\n",
    "    df = cumulate_states(df, 'Canada')\n",
    "    df = cumulate_states(df, 'China')\n",
    "    df = rename_provinces(df, 'Denmark')\n",
    "    df = rename_provinces(df, 'France')\n",
    "    df = rename_provinces(df, 'Netherlands')\n",
    "    df = rename_provinces(df, 'United Kingdom')\n",
    "    if verbose:\n",
    "        print()\n",
    "        print('Duplicate entries in \"Country/Region\" column AFTER data preparation')\n",
    "        list_duplicates(df)\n",
    "    if get_location:\n",
    "        df_loc = df[['Country/Region', 'Lat', 'Long']].transpose()\n",
    "        df_loc = df_loc.rename(columns=df_loc.iloc[0]).drop('Country/Region')\n",
    "    df = transpose_and_remove_location(df)\n",
    "    if get_location:\n",
    "        return df, df_loc\n",
    "    return df\n",
    "\n",
    "\n",
    "df_confirmed, df_loc = prepare_data(df_confirmed, verbose=False, get_location=True)\n",
    "df_deaths = prepare_data(df_deaths, verbose=False)\n",
    "# df_recovered = prepare_data(df_recovered, verbose=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Manual correction of locations\n",
    "df_loc['Canada']['Lat'], df_loc['Canada']['Long'] = 52.9399, -106.4509\n",
    "df_loc['Belize']['Lat'], df_loc['Belize']['Long'] = 17.15, -88.46\n",
    "df_loc['Congo (Brazzaville)']['Lat'], df_loc['Congo (Brazzaville)']['Long'] = -4.16, 15.17"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def convert_day(day):\n",
    "    month, day, year = day.split('/')\n",
    "    return '{0:02d}. {1:01d}.'.format(int(day), int(month))\n",
    "\n",
    "dates = [convert_day(day) for day in df_confirmed.index]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Plots\n",
    "\n",
    "### I) Number of confirmed cases and deaths\n",
    "\n",
    "At which stage of the outbreak are various countries around the globe? How are the case numbers developing?\n",
    "\n",
    "Comparison of Austria with different contexts (neighbors, continents, global worst cases) on logarithmic y-scales to see exponential growth and deviations from it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "colors = [\"#444\", \"#6059a0\", \"#df4828\", \"#69b190\", \"#ddaa3c\", \"#d1c1e1\", \"#4e96bc\", \"#95211b\",\n",
    "          \"#a6be54\", \"#e67932\", \"#9b62a7\", \"#4e79c5\", \"#521a13\", \"#8cbc68\", \"#e4632d\", \"#b58fc2\"]\n",
    "\n",
    "\n",
    "def plot_cases(countries, title=None):\n",
    "    data = [df_confirmed[country].tolist() for country in countries] + \\\n",
    "           [df_deaths[country].tolist() for country in countries]\n",
    "    num_vectors = len(data)\n",
    "    num_countries = len(countries)\n",
    "\n",
    "    title_kwargs = dict()\n",
    "    if title:\n",
    "        title_kwargs['show_title'] = True\n",
    "        title_kwargs['title'] = 'Confirmed cases and deaths in {}'.format(title)\n",
    "\n",
    "    fig = up.matplotlib.scatter(\n",
    "        x=[dates]*num_vectors,\n",
    "        y=data,\n",
    "        name=['{}: confirmed'.format(c) for c in countries] + ['{}: deaths'.format(c) for c in countries],\n",
    "        color=colors[:num_countries]*2,\n",
    "\n",
    "        marker_size=[5.0]*num_countries + [4.0]*num_countries,\n",
    "        marker_style=['o']*num_countries + ['+']*num_countries,\n",
    "        show_line=True,\n",
    "        line_width=[3.5] *num_countries + [1.0]*num_countries,\n",
    "        line_style=['-']*num_countries + ['.']*num_countries,\n",
    "        line_opacity=0.6,\n",
    "        \n",
    "        x_axis_scale='categorical',\n",
    "        x_title='Days',\n",
    "        x_label_rotation=90,\n",
    "        x_label_size=9,\n",
    "        x_axis_range=[0, len(dates)-1],\n",
    "\n",
    "        y_title='Number of cases',\n",
    "        y_axis_scale='log',\n",
    "        y_axis_range=[1, 1e6],\n",
    "        show_y_grid=True,\n",
    "        \n",
    "        width_mm=300,\n",
    "        legend_position_horizontal='left',\n",
    "        legend_size=7,\n",
    "        **title_kwargs,\n",
    "    )\n",
    "    fig.display(inline=True)\n",
    "\n",
    "\n",
    "def plot_comparison(df, countries, ms='o', ls='-', title=None, threshold=10):\n",
    "    day_counter, cases = [], []\n",
    "    for country in countries:\n",
    "        values = df[country].tolist()\n",
    "        try:\n",
    "            index_of_first_value = next(i for i, val in enumerate(values) if val > threshold)\n",
    "            diff = abs(threshold - values[index_of_first_value])\n",
    "            if abs(threshold - values[index_of_first_value - 1]) < diff:\n",
    "                index_of_first_value -= 1\n",
    "        except StopIteration:\n",
    "            message = ('Country \"{}\" does not have a number above the given threshold '\n",
    "                       'of {} cases.'.format(country, threshold))\n",
    "            raise ValueError(message) from None\n",
    "        y = list(values)[index_of_first_value:]\n",
    "        x = list(range(len(y)))\n",
    "        day_counter.append(x)\n",
    "        cases.append(y)\n",
    "\n",
    "    title_kwargs = dict()\n",
    "    if title:\n",
    "        title_kwargs['show_title'] = True\n",
    "        title_kwargs['title'] = title\n",
    "\n",
    "    fig = up.matplotlib.scatter(\n",
    "        x=day_counter,\n",
    "        y=cases,\n",
    "        name=countries,\n",
    "        color=colors,\n",
    "\n",
    "        marker_size=[7]+[4]*20,\n",
    "        marker_style=ms,\n",
    "        show_line=True,\n",
    "        line_width=1.2,\n",
    "        line_style=ls,\n",
    "        line_opacity=0.4,\n",
    "        \n",
    "        x_title='Day since number of cases was around a value of {} for the first time'.format(threshold),\n",
    "        x_axis_range=[0, max(max(cnts) for cnts in day_counter)],\n",
    "        \n",
    "        y_title='Number of cases',\n",
    "        y_axis_scale='log',\n",
    "        y_axis_range=[1, 1e6],\n",
    "        show_y_grid=True,\n",
    "        \n",
    "        width_mm=300,\n",
    "        legend_position_horizontal='left',\n",
    "        legend_size=7,\n",
    "        **title_kwargs,\n",
    "    )\n",
    "    fig.display(inline=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "austria_and_neighbors = [\n",
    "    'Austria', 'Germany', 'Switzerland', 'Italy', 'Hungary',  'Czechia', 'Slovakia', 'Slovenia', 'Liechtenstein']\n",
    "austria_and_europe = [\n",
    "    'Austria', 'Italy', 'Spain', 'France',  'United Kingdom', 'Netherlands', 'Belgium', 'Sweden', 'Denmark']\n",
    "austria_and_asia = [\n",
    "    'Austria', 'China', 'Japan', 'Korea, South', 'Taiwan*', 'Singapore', 'Vietnam', 'Malaysia', 'India']\n",
    "austria_and_america = [\n",
    "    'Austria', 'US', 'Canada', 'Mexico', 'Cuba', 'Colombia', 'Peru', 'Brazil', 'Argentina', 'Chile']\n",
    "austria_and_africa = [\n",
    "    'Austria', 'Morocco', 'Algeria', 'Egypt', 'Nigeria', 'Ethiopia', 'Madagascar', 'Angola', 'South Africa'\n",
    "]\n",
    "\n",
    "def find_countries_with_max_values(df, n):\n",
    "    countries = df.columns.tolist()\n",
    "    latest_values = df.iloc[-1].tolist()\n",
    "    sort_indices = sorted(range(len(latest_values)), key=lambda i: -latest_values[i])\n",
    "    countries_max = [countries[i] for i in sort_indices[:n]]\n",
    "    return countries_max\n",
    "\n",
    "austria_and_max_val_countries = ['Austria'] + find_countries_with_max_values(df_confirmed, 10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "plot_cases(austria_and_max_val_countries, 'Austria and countries with highest case numbers')\n",
    "\n",
    "plot_comparison(\n",
    "    df_confirmed, austria_and_max_val_countries, threshold=100,\n",
    "    title='Growth comparison of confirmed cases in Austria and countries with highest case numbers')\n",
    "\n",
    "plot_comparison(\n",
    "    df_deaths, austria_and_max_val_countries, ms='+', ls='.', threshold=10,\n",
    "    title='Growth comparison of deaths in Austria and countries with highest case numbers')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "plot_cases(austria_and_neighbors, 'Austria and its neighboring countries')\n",
    "plot_cases(austria_and_europe, 'Austria and Europe')\n",
    "plot_cases(austria_and_asia, 'Austria and Asia')\n",
    "plot_cases(austria_and_america, 'Austria and America')\n",
    "plot_cases(austria_and_africa, 'Austria and Africa')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "filepath = os.path.join('..', '..', 'data', 'networks', 'neighboring_countries.json')\n",
    "country_data = up.utilities.io.read_json_file(filepath)\n",
    "\n",
    "graph = nx.Graph()\n",
    "known_edges = set()\n",
    "for source, targets in country_data.items():\n",
    "    for target in targets:\n",
    "        if (target, source) not in known_edges:\n",
    "            known_edges.add((source, target))\n",
    "            graph.add_edge(source, target)\n",
    "\n",
    "            \n",
    "countries_wiki = sorted(country_data.keys())\n",
    "countries_jhu = sorted(df_confirmed.columns)\n",
    "jhu_to_wikipedia_name = {\n",
    "    # \"Bermuda\": ?\n",
    "    \"Burma\": \"Myanmar\",\n",
    "    \"Cabo Verde\": \"Cape Verde\",\n",
    "    # \"Channel Islands\": ?\n",
    "    \"Congo (Brazzaville)\": \"Republic of the Congo\",\n",
    "    \"Congo (Kinshasa)\": \"Democratic Republic of the Congo\",\n",
    "    \"Cote d'Ivoire\": \"Côte d'Ivoire\",\n",
    "    \"Curacao\": \"Curaçao\",\n",
    "    \"Czechia\": \"Czech Republic\",\n",
    "    # \"Diamond Princess\": ?  ... a ship, not a country\n",
    "    \"Eswatini\": \"Eswatini (Swaziland)\",\n",
    "    \"French Guiana\": \"Guinea\",  # what about \"Guinea-Bissau\"?\n",
    "    \"Gambia\": \"The Gambia\",\n",
    "    # \"Guadeloupe\": ?\n",
    "    \"Holy See\": \"Vatican City\",\n",
    "    \"Korea, South\": \"South Korea\",\n",
    "    # MS Zaandam\n",
    "    # Martinique\n",
    "    # Mayotte\n",
    "    # Reunion\n",
    "    \"Saint Barthelemy\": \"Saint Barthélemy\",\n",
    "    \"St Martin\": \"Saint Martin\",\n",
    "    \"Taiwan*\": \"Taiwan\",\n",
    "    \"Timor-Leste\": \"East Timor\",\n",
    "    \"US\": \"United States\",\n",
    "    #\"West Bank and Gaza\": ?\n",
    "}\n",
    "\n",
    "def plot_single_country(country):\n",
    "    chosen_label_indices = range(0, len(df_confirmed.index), 5)\n",
    "    dates = df_confirmed.index\n",
    "    fig = up.matplotlib.scatter(\n",
    "        x=[dates, dates],\n",
    "        y=[df_confirmed[country], df_deaths[country]],\n",
    "        name=['Confirmed cases', 'Deaths'],\n",
    "        show_title=True,\n",
    "        title=country_jhu,\n",
    "        x_axis_scale='cat',\n",
    "        x_title='Days',\n",
    "        x_tick_position=chosen_label_indices,\n",
    "        x_label=[df_confirmed.index[i] for i in chosen_label_indices],\n",
    "        x_label_rotation=45,\n",
    "        x_axis_range=[0, len(dates)],\n",
    "        y_axis_scale='log',\n",
    "        y_title='Number of cases',\n",
    "        y_axis_range=[1, 1e6],\n",
    "        show_y_grid=True,\n",
    "        show_marker=False,\n",
    "        show_line=True,\n",
    "        line_width=3,\n",
    "        legend_position_horizontal='left',\n",
    "        height_mm=125,\n",
    "        width_mm=175,\n",
    "    )\n",
    "    return fig\n",
    "\n",
    "for country_jhu in df_confirmed.columns:\n",
    "    country_wiki = jhu_to_wikipedia_name.get(country_jhu, country_jhu)\n",
    "    try:\n",
    "        node = graph.nodes[country_wiki]\n",
    "        for date in df_confirmed.index:\n",
    "            val_confirmed = df_confirmed[country_jhu][date]\n",
    "            val_deaths = df_deaths[country_jhu][date]\n",
    "            val_confirmed_scaled = math.log(val_confirmed+1)**2\n",
    "            val_deaths_scaled = math.log(val_deaths+1)**2\n",
    "            node['{} confirmed'.format(convert_day(date))] = val_confirmed_scaled\n",
    "            node['{} deaths'.format(convert_day(date))] = val_deaths_scaled\n",
    "        node['hover'] = plot_single_country(country_jhu).svg_text\n",
    "        node['x'] = df_loc[country_jhu]['Long'] * 15\n",
    "        node['y'] = -df_loc[country_jhu]['Lat'] * 15\n",
    "    except Exception:\n",
    "        pass\n",
    "\n",
    "\n",
    "up.javascript.network_d3(\n",
    "    graph, zoom_factor=0.15, use_centering_force=False, edge_curvature=0.2,\n",
    "    node_size_data_source='31. 3. confirmed', use_node_size_normalization=True,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### II) Daily growth rates\n",
    "\n",
    "What are the factors (or percentages) between daily case numbers? How is the growth rate developing over time?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "def plot_rates(df, last_n, what, countries, title):\n",
    "    title = 'Growth rates of {} over last {} days in {}'.format(what, last_n, title)\n",
    "    fig = up.plotly.bar(\n",
    "        x=[dates[-last_n:]]*len(countries),\n",
    "        y=[df[c].tolist()[-last_n:] for c in countries],\n",
    "        name=countries,\n",
    "        x_axis_scale='cat',\n",
    "        color=colors,\n",
    "        title=title,\n",
    "        show_title=True,\n",
    "        show_x_title=False,\n",
    "        y_title='Relative change',\n",
    "        x_label_rotation=90,\n",
    "        width_mm=250,\n",
    "    )\n",
    "    fig.display(inline=True)\n",
    "\n",
    "\n",
    "def plot_rate_statistics(df, last_n, what, countries, title):\n",
    "    used_data = [df[c].tolist()[-last_n:] for c in countries]\n",
    "    title = 'Growth rates of {} over last {} days in {}'.format(what, last_n, title)\n",
    "    \n",
    "    fig = up.plotly.box(\n",
    "        used_data,\n",
    "        name=countries,\n",
    "        color=colors,\n",
    "        width_mm=250,\n",
    "        x_label_rotation=25,\n",
    "        title=title,\n",
    "        show_title=True,\n",
    "        show_x_title=False,\n",
    "        show_y_title=False,\n",
    "    )\n",
    "    fig += up.plotly.violin(used_data, name=countries, color=colors, show_rug=False, opacity=0.3)\n",
    "    fig.display(inline=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "df_confirmed_rates = df_confirmed.pct_change().replace(float('inf'), float('nan')).fillna(0.0)\n",
    "df_deaths_rates = df_deaths.pct_change().replace(float('inf'), float('nan')).fillna(0.0)\n",
    "countries = ['Austria', 'Italy', 'Spain', 'France', 'United Kingdom', 'US']\n",
    "last_n = 14\n",
    "\n",
    "plot_rates(\n",
    "    df_confirmed_rates, last_n, 'confirmed cases',\n",
    "    austria_and_max_val_countries, 'Austria and countries with highest numbers')\n",
    "plot_rate_statistics(\n",
    "    df_confirmed_rates, last_n, 'confirmed cases',\n",
    "    austria_and_max_val_countries, 'Austria and countries with highest numbers')\n",
    "\n",
    "plot_rates(\n",
    "    df_deaths_rates, last_n, 'deaths',\n",
    "    austria_and_max_val_countries, 'Austria and countries with highest numbers')\n",
    "plot_rate_statistics(\n",
    "    df_deaths_rates, last_n, 'deaths',\n",
    "    austria_and_max_val_countries, 'Austria and countries with highest numbers')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### III) Correlations between daily growth rates of different countries\n",
    "\n",
    "Are there groups of countries where the measured growth rates behave similar over time? Could this help to predict further developments in certain countries or (connected) regions?\n",
    "\n",
    "Note: For some countries the number of confirmed cases or deaths is not monotonically increasing, which might be an inconsistency in data collection? The result is that there are a few negative growth rates."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "num_countries = len(df_confirmed_rates.columns)\n",
    "n = 60\n",
    "n_used = n-1\n",
    "\n",
    "up.matplotlib.scatter(\n",
    "    x=[dates[-n_used:]]*num_countries + \\\n",
    "        [dates[-n_used:]]*num_countries,\n",
    "    y=[df_confirmed_rates[col][-n_used:] for col in df_confirmed_rates.columns] + \n",
    "        [df_deaths_rates[col][-n_used:] for col in df_deaths_rates.columns],\n",
    "    x_axis_scale='cat',\n",
    "    color=['black']*num_countries + ['red']*num_countries,\n",
    "    title='Growth rates of confirmed cases (black) and deaths (red) in '\n",
    "          'all countries over the last {} days.'.format(n),\n",
    "    show_title=True,\n",
    "    show_line=True,\n",
    "    show_legend=False,\n",
    "    show_marker=False,\n",
    "    line_width=0.3,\n",
    "    width_mm=300,\n",
    "    height_mm=150,\n",
    "    x_label_rotation=90,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "corr_last_n = 21  # seems a reasonable time window where many countries have measured dynamics (see plot above)\n",
    "df_confirmed_rates_corr = df_confirmed_rates.iloc[-corr_last_n:].corr()\n",
    "df_deaths_rates_corr = df_deaths_rates.iloc[-corr_last_n:].corr()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_confirmed_rates_corr = df_confirmed_rates_corr.fillna(0)\n",
    "df_deaths_rates_corr = df_deaths_rates_corr.fillna(0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "def plot_heatmap(df, title):\n",
    "    fig = up.plotly.heatmap(\n",
    "        x=df.index,\n",
    "        y=df.columns,\n",
    "        z=[df[col] for col in df.columns],\n",
    "        x_axis_scale='cat',\n",
    "        y_axis_scale='cat',\n",
    "        x_label_rotation=90,\n",
    "        width_mm=250,\n",
    "        height_mm=250,\n",
    "        title=title,\n",
    "        show_title=True,\n",
    "        show_x_title=False,\n",
    "        show_y_title=False,\n",
    "        show_x_label=False,\n",
    "        show_y_label=False,\n",
    "        show_x_tick=False,\n",
    "        show_y_tick=False,\n",
    "    )\n",
    "    fig.display(inline=True)\n",
    "\n",
    "\n",
    "plot_heatmap(\n",
    "    df_confirmed_rates_corr,\n",
    "    'Pearson correlation coefficient between series of daily growth rates of confirmed cases '\n",
    "    'in all countries over last {} days'.format(corr_last_n))\n",
    "plot_heatmap(\n",
    "    df_deaths_rates_corr,\n",
    "    'Pearson correlation coefficient between series of daily growth rates of deaths '\n",
    "    'in all countries over last {} days'.format(corr_last_n))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# consider rates of both confirmed cases and deaths\n",
    "threshold = 0.65\n",
    "df_used = (df_confirmed_rates_corr + df_deaths_rates_corr) / 2\n",
    "df_threshold = (df_used > threshold).astype(int)\n",
    "\n",
    "up.plotly.heatmap(\n",
    "    x=df_threshold.index,\n",
    "    y=df_threshold.columns,\n",
    "    z=[df_threshold[col] for col in df_threshold.columns],\n",
    "    x_axis_scale='cat',\n",
    "    y_axis_scale='cat',\n",
    "    x_label_rotation=90,\n",
    "    colormap='gray',\n",
    "    colormap_reversed=True,\n",
    "    show_colormap=False,\n",
    "    show_x_title=False,\n",
    "    show_y_title=False,\n",
    "    show_x_label=False,\n",
    "    show_y_label=False,\n",
    "    show_x_tick=False,\n",
    "    show_y_tick=False,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import networkx as nx\n",
    "\n",
    "graph = nx.Graph()\n",
    "for c1 in df_threshold.index:\n",
    "    graph.add_node(c1)\n",
    "    for c2 in df_threshold.columns:\n",
    "        if df_threshold[c1][c2] and c1 != c2:\n",
    "            graph.add_edge(c1, c2)\n",
    "\n",
    "node_centralities = nx.degree_centrality(graph)\n",
    "#node_centralities = nx.betweenness_centrality(graph)\n",
    "#edge_centralities = nx.edge_betweenness_centrality(graph)\n",
    "communities = nx.algorithms.community.greedy_modularity_communities(graph)\n",
    "\n",
    "for node_id in graph.nodes:\n",
    "    node = graph.nodes[node_id]\n",
    "    #node['x'] = df_loc[node_id]['Long'] * 10\n",
    "    #node['y'] = -df_loc[node_id]['Lat'] * 10\n",
    "    node['size'] = 5 + node_centralities[node_id] * 400\n",
    "    for community_counter, community_members in enumerate(communities):\n",
    "            if node_id in community_members:\n",
    "                break\n",
    "    node['color'] = colors[community_counter % len(colors)]\n",
    "    if graph.degree(node_id) == 0:\n",
    "        node['color'] = 'gray'\n",
    "\n",
    "for edge_id in graph.edges:\n",
    "    country1, country2 = edge_id\n",
    "    edge =  graph.edges[edge_id]\n",
    "    source_node = graph.nodes[edge_id[0]]\n",
    "    target_node = graph.nodes[edge_id[1]]\n",
    "    correlation = df_used[country1][country2]\n",
    "    edge['size'] = correlation * 5\n",
    "    #edge['size'] = 1 + edge_centralities[edge_id] * 300\n",
    "    edge['color'] = source_node['color'] if source_node['color'] == target_node['color'] else 'lightgray'\n",
    "\n",
    "graph.graph['node_border_color'] = 'white'\n",
    "graph.graph['node_border_size'] = 1.5\n",
    "\n",
    "print()\n",
    "print('Network of countries with similar dynamics in their measured growth numbers, '\n",
    "      'i.e. large positive linear correlation between series of growth rates of both confirmed cases and deaths')\n",
    "up.javascript.network_d3(graph, use_centering_force=False, zoom_factor=0.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_rate_similarities(df, last_n, what, countries):\n",
    "    data = [list(range(last_n))] + [df[c].tolist()[-last_n:] for c in countries]\n",
    "    names = ['Day'] + countries\n",
    "    fig = up.javascript.parallel_coordinates_table(data, name=names, opacity=1.0)\n",
    "    fig.display(inline=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "cluster1 = ['Germany', 'Netherlands', 'Belgium', 'Spain', 'Switzerland']\n",
    "cluster2 = ['Austria', 'Malaysia', 'Ecuador', 'Turkey', 'Panama']\n",
    "cluster3 = ['Czechia', 'Cyprus', 'Congo (Kinshasa)', 'Bosnia and Herzegovina', 'Thailand',]\n",
    "cluster4 = ['Italy', 'Luxembourg', 'Indonesia', 'Portugal', 'Brazil']\n",
    "cluster5 = ['Guadeloupe', 'Jordan', 'Cameroon', 'Armenia', 'Saudi Arabia']\n",
    "\n",
    "for correlated_countries in [cluster1, cluster2, cluster3, cluster4, cluster5]:\n",
    "    plot_rates(\n",
    "        df_confirmed_rates, corr_last_n, 'confirmed cases',\n",
    "        correlated_countries, 'in countries with correlated growth rates in this time')\n",
    "\n",
    "    plot_rate_similarities(df_confirmed_rates, corr_last_n, 'confirmed cases', correlated_countries)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
